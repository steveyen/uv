#!/usr/bin/env ruby

# Poor man's lite "SWIG" just for lua, which uses STDIN and STDOUT.
#
#   ./swiglite-lua <module_name> [opt.h opt2.h ...]
#
# Example:
#
#   grep -v "#include" some.h | cpp | \
#     ./swiglite-lua some_wrap some.h > some_wrap.c
#
# License   : Apache 2.0
# Copyright : Steve Yen, Inc., 2011.
#
load('swiglite')

require 'rubygems'
require 'erb'

# ---------------------------------------------

SKIP = {}

MAP_TYPE = {
  # [ luaL_check$VAL, lua_push$VAL ]
  'int'     => ['int', 'integer'],
  'long'    => ['long', 'integer'],
  'int64_t' => ['long', 'integer'], # TODO: Revisit int64_t.
  'size_t'  => ['long', 'integer'],
  'double'  => ['number', 'number'],
  'char *'  => ['string', 'string']
}

$module_name   = ARGV[0]
$include_files = ARGV[1..-1]

$src = STDIN.read
$src = $src.gsub(/^\s*#.+$/, '')

KINDS = {}

# User's module-specific specializations loaded here.
#
[ ".swiglite", ".swiglite-lua" ].each do |suffix|
  load($module_name + suffix) if File.exists?($module_name + suffix)
end

parse($src, KINDS)

ENUMS     = KINDS['enum']     || {}
TYPEDEFS  = KINDS['typedef']  || {}
FUNCTIONS = KINDS['function'] || {}

# ---------------------------------------------

def map_type(c_type) # Ex: ['char *'] or ['char', '*'].
  type_key = c_type.join(' ').
                    gsub('unsigned ', '').
                    gsub('signed ', '').
                    squeeze(' ').strip

  check_val, push_val = MAP_TYPE[type_key]

  if check_val.nil? and ENUMS[type_key]
    check_val, push_val = MAP_TYPE['int'] # Treat enum as int.
  end

  type_name = type_key.gsub('*', ' * ').
                       gsub('*', 'ptr').
                       gsub('struct ', '').
                       gsub('const ', '').
                       squeeze(' ').strip.
                       gsub(' ', '_')

  return type_name, check_val, push_val
end

def arg_from_lua(arg_type, arg_name, arg_i)
  i = arg_i + 1
  type_name, check_val, push_val = map_type(arg_type)
  if check_val
    "#{arg_name} = (#{arg_type.join(' ')})" +
      " luaL_check#{check_val}(L, #{i});\n"
  else
    <<-EOF
#{arg_type.join(' ')} *#{arg_name}_p =
        luaL_checkudata(L, #{i}, "#{$module_name}.#{type_name}");
    #{arg_name} = *#{arg_name}_p;
EOF
  end
end

# ---------------------------------------------

print <<-EOF
// wrapping for #{$module_name} generated by swiglite-lua.

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#{$include_files.map {|x| "#include \"#{x}\"" }.join("\n")}

EOF

if true
  print("/* inputs...\n")
  KINDS.keys.sort.each do |k|
    print("  #{k}:\n")
    kind = KINDS[k]
    kind.keys.sort.each do |n|
      print("    #{n}:\n")
      print("      #{kind[n].join('><')}\n")
    end
  end
  print("\n*/\n\n")
end

# ---------------------------------------------

FUNCTIONS.keys.sort.each do |k|
  decl = FUNCTIONS[k]

  name, kind, return_type = parse_decl(decl)

  args_s = decl[(decl.rindex("(") + 1)..-2].join('').strip
  args_s = "" if args_s == "void"
  args   = args_s.split(',')

  unless SKIP[name]
    print(ERB.new(<<-'EOF', 0, "%<>").result(binding))
static int wrap_<%= name %>(lua_State *L) {
% args.each_index do |arg_i|
%   arg_type, arg_name = arg_parts(args[arg_i], arg_i)
    <%= arg_type.join(' ') %> <%= arg_name %>;
    <%= arg_from_lua(arg_type, arg_name, arg_i) %>
% end
% if return_type.include?('void')
    <%= name %>(<%= args_names(args).join(', ') %>);
    return 0;
% else
%   return_s = return_type.join(' ').
%                          gsub('*', ' * ').
%                          gsub('const ', '').
%                          squeeze(' ').strip
    <%= return_s %> res = (<%= return_s %>)
        <%= name %>(<%= args_names(args).join(', ') %>);
%   type_name, check_val, push_val = map_type(return_s.split(' '))
%   if push_val
    lua_push<%= push_val %>(L, res);
    return 1;
%   else
    <%= return_s %> *res_ud =
        lua_newuserdata(L, sizeof(<%= return_s %>));
    if (res_ud != NULL) {
        *res_ud = res;
        luaL_newmetatable(L, "<%= $module_name %>.<%= type_name %>");
        lua_setmetatable(L, -2);
        return 1;
    }
    return 0;
%   end
% end
}
EOF
  end
end

# ---------------------------------------------

TYPEDEFS.keys.sort.each do |k|
  decl = TYPEDEFS[k]

  name, kind, sub_kind = parse_decl(decl)
  if sub_kind != 'function'
     print(ERB.new(<<-'EOF', 0, "%<>").result(binding))
EOF
  end
end

# ---------------------------------------------

print(ERB.new(<<-'EOF', 0, "%<>").result(binding))
LUA_API int luaopen_<%= $module_name %>(lua_State *L) {
    luaL_reg reg[] = {
% FUNCTIONS.keys.sort.each do |k|
%   unless SKIP[k]
        {"<%= k %>", wrap_<%= k %>},
%   end
% end
        {NULL, NULL}
    };
    luaL_register(L, "<%= $module_name %>", reg);

% ENUMS.keys.sort.each do |k|
%   parse_enum_values(ENUMS[k]).each do |v|
    lua_pushinteger(L, (lua_Integer) <%= v %>);
    lua_setfield(L, -2, "<%= v %>");

%   end
% end
    return 1;
}
EOF
