#!/usr/bin/env ruby

# Poor man's lite SWIG just for lua, which uses STDIN and STDOUT.
#
#   ./swiglite-lua <module_name> [opt.h opt2.h ...]
#   cat some.h | ./swiglite-lua some_wrap some.h > some_wrap.c
#
# license   : Apache 2.0
# copyright : Couchbase, Inc., 2011.
#
load('swiglite')

require 'rubygems'
require 'erb'

# ---------------------------------------------

SKIP = {}

MAP_TYPE = {
  # [ luaL_check$VAL, lua_push$VAL ]
  'int'    => ['int', 'integer'],
  'long'   => ['long', 'integer'],
  'double' => ['number', 'number'],
  'char *' => ['string', 'string']
}

$module_name   = ARGV[0]
$include_files = ARGV[1..-1]

$src = STDIN.read
$src = $src.gsub(/^\s*#.+$/, '')

# User's module-specific specializations loaded here.
#
[ ".swiglite", ".swiglite-lua" ].each do |suffix|
  load($module_name + suffix) if File.exists?($module_name + suffix)
end

KINDS     = parse($src)
ENUMS     = KINDS['enum']
FUNCTIONS = KINDS['function']

# ---------------------------------------------

def map_type(c_type) # Ex: ['char *'] or ['char', '*'].
  type_key = c_type.join(' ').
                    gsub('unsigned ', '').
                    gsub('signed ', '').
                    squeeze(' ').strip

  check_val, push_val = MAP_TYPE[type_key]

  type_name = type_key.gsub('*', 'ptr').
                       gsub('struct ', '').
                       gsub('const ', '').
                       gsub(' ', '_')

  return type_name, check_val, push_val
end

# ---------------------------------------------

print <<-EOF
// wrapping for #{$module_name} generated by swiglite-lua.

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#{$include_files.map {|x| "#include \"#{x}\"" }.join("\n")}

EOF

if true
  print("/* inputs...\n")
  KINDS.keys.sort.each do |k|
    print("  #{k}:\n")
    kind = KINDS[k]
    kind.keys.sort.each do |n|
      print("    #{n}:\n")
      print("      #{kind[n].join('><')}\n")
    end
  end
  print("\n*/\n\n")
end

# ---------------------------------------------

def arg_from_lua(arg_type, arg_name, arg_i)
  i = arg_i + 1
  type_name, check_val, push_val = map_type(arg_type)
  if check_val
    "#{arg_name} = (#{arg_type.join(' ')}) luaL_check#{check_val}(L, #{i});\n"
  else
    <<-EOF
#{arg_type.join(' ')} *#{arg_name}_p =
        luaL_checkudata(L, #{i}, "#{$module_name}.#{type_name}");
    #{arg_name} = *#{arg_name}_p;
EOF
  end
end

# ---------------------------------------------

wrap_function = ERB.new(<<-'EOF', 0, "%<>")
static int wrap_<%= name %>(lua_State *L) {
% args.each_index do |arg_i|
%   arg_type, arg_name = arg_parts(args[arg_i], arg_i)
    <%= arg_type.join(' ') %> <%= arg_name %>;
    <%= arg_from_lua(arg_type, arg_name, arg_i) %>
% end
% if return_type.include?('void')
    <%= name %>(<%= args_names(args).join(', ') %>);
    return 0;
% else
%   return_s = return_type.join(' ').
%                          gsub('*', ' * ').squeeze(' ').strip
    <%= return_s %> res =
        <%= name %>(<%= args_names(args).join(', ') %>);
%   type_name, check_val, push_val = map_type(return_type)
    return 0;
% end
}
EOF

FUNCTIONS.keys.sort.each do |k|
  curr = FUNCTIONS[k]

  name, kind, return_type = name_kind(curr)

  args_s = curr[(curr.rindex("(") + 1)..-2].join('').strip
  args_s = "" if args_s == "void"
  args   = args_s.split(',')

  print(wrap_function.result(binding)) unless SKIP[name]
end

# ---------------------------------------------

entrypoint_template = ERB.new(<<-'EOF', 0, "%<>")
LUA_API int luaopen_<%= $module_name %>(lua_State *L) {
    luaL_reg reg[] = {
% FUNCTIONS.keys.sort.each do |k|
%   unless SKIP[k]
        {"<%= k %>", wrap_<%= k %>},
%   end
% end
        {NULL, NULL}
    };
    luaL_register(L, "<%= $module_name %>", reg);

% ENUMS.keys.sort.each do |k|
%   enum_values(ENUMS[k]).each do |v|
    lua_pushinteger(L, (lua_Integer) <%= v %>);
    lua_setfield(L, -2, "<%= v %>");

%   end
% end

    return 1;
}
EOF

print(entrypoint_template.result(binding))
