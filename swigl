#!/usr/bin/env ruby

# Poor man's SWIG just for lua, which uses STDIN/STDOUT.
#
#   cat some.h | ./swigl some_wrap > some_wrap.c
#
modname = ARGV[0]

src = STDIN.read
src = src.gsub(/^\s*#.+$/, '')

def name_kind(curr)
  first_parts = curr[0].split(' ').
                        select {|x| x != "extern" and x != "__const" }

  case first_parts[0]
    when 'typedef'
      if curr[-1] == ')' and
         curr.count {|x| x == '(' } > 1
        # Example: typedef void (*uv_close_cb)(uv_handle_t* handle);
        return curr[curr.index('(') + 1], first_parts[0]
      end

      # Example: typedef enum { ...} name_of_enum;
      return curr[-1].split(' ')[-1], 'enum' if first_parts[1] == 'enum'

      # Example: typedef struct uv_req_s uv_req_t;
      return curr[-1].split(' ')[-1], first_parts[0]

    when 'struct', 'union', 'enum'
      # Example: struct cmsghdr
      # Example: struct cmsghdr{int foo; int bar}
      return first_parts[-1], first_parts[0]

    else
      # Example: void uv_init();
      return first_parts[-1], 'function' if curr.include?('(')

      print "ERROR: unknown name/type for #{curr.join("><")}\n"
      exit(-1)
  end
end

kinds = {}
curr = []

parts = src.split(/([\;\{\}\(\)])/)
parts.each do |part|
  if part
    part = part.strip.squeeze(" \n\t")
    if part != ""
      if part == ";" and
         curr.count {|x| x == "{" } == curr.count {|x| x == "}" }
        n, k = name_kind(curr)
        if n.nil? or k.nil?
          print "\n\nERROR: missing name in #{curr.join("><")}\n"
          exit(-1)
        end

        n = n.gsub('*', '')

        kinds[k] ||= {}
        if kinds[k][n]
          print("ERROR: duplicate name: #{n}, for kind: #{k}," \
                " in: #{curr.join('><')}, previously: #{kinds[k][n].join('><')}\n")
        end

        kinds[k][n] = curr

        curr = []
      else
        curr << part
      end
    end
  end
end

if true
  print("/* lua wrapping generated by swigl.\n")
  print("\n")
  print("#{modname}:\n")
  kinds.keys.sort.each do |k|
    print("  #{k}:\n")
    kind = kinds[k]
    kind.keys.sort.each do |n|
      print("    #{n}:\n")
      print("      #{kind[n].join('><').gsub("\n", " ").squeeze(" ")}\n")
    end
  end
  print("\n")
  print("*/\n")
  print("\n")
end



