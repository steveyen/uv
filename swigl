#!/usr/bin/env ruby

# Poor man's SWIG just for lua, which uses STDIN/STDOUT.
#
#   ./swigl <module_name> [opt.h opt2.h ...]
#   cat some.h | ./swigl some_wrap some.h > some_wrap.c
#
require 'rubygems'
require 'erb'

module_name   = ARGV[0]
include_files = ARGV[1..-1]

src = STDIN.read
src = src.gsub(/^\s*#.+$/, '')

# ---------------------------------------------

def name_kind(curr)
  first_parts = curr[0].split(' ').
                        select {|x| x != "extern" and x != "__const" }

  case first_parts[0]
    when 'typedef'
      if curr[-1] == ')' and
         curr.count {|x| x == '(' } > 1
        # Example: typedef void (*uv_close_cb)(uv_handle_t* handle);
        return curr[curr.index('(') + 1], first_parts[0], 'function'
      end

      # Example: typedef enum { ...} name_of_enum;
      return curr[-1].split(' ')[-1], 'enum' if first_parts[1] == 'enum'

      # Example: typedef struct uv_req_s uv_req_t;
      return curr[-1].split(' ')[-1], first_parts[0]

    when 'struct', 'union', 'enum'
      # Example: struct cmsghdr
      # Example: struct cmsghdr{int foo; int bar}
      return first_parts[-1], first_parts[0]

    else
      # Example: void uv_init();
      return first_parts[-1], 'function' if curr.include?('(')

      print "ERROR: unknown name/type for #{curr.join("><")}\n"
      exit(-1)
  end
end

def enum_values(curr)
  res = []
  lhs = curr.index('{') + 1
  rhs = curr.index('}') - 1
  vals = curr[lhs..rhs]
  vals.each do |e|
    e.split(',').each do |v|
      v = v.split('=')[0]
      res << v
    end
  end
  res
end

# ---------------------------------------------

kinds = {}
curr = []

parts = src.split(/([\;\{\}\(\)])/)
parts.each do |part|
  if part
    part = part.strip.gsub("\n", " ").squeeze(" \n\t")
    if part != ""
      if part == ";" and
         curr.count {|x| x == "{" } == curr.count {|x| x == "}" }
        n, k = name_kind(curr)
        if n.nil? or k.nil?
          print "\n\nERROR: missing name in #{curr.join("><")}\n"
          exit(-1)
        end

        n = n.gsub('*', '')

        kinds[k] ||= {}
        if kinds[k][n]
          print("ERROR: duplicate name: #{n}, for kind: #{k}," \
                " in: #{curr.join('><')}," \
                " previously: #{kinds[k][n].join('><')}\n")
        end

        kinds[k][n] = curr

        curr = []
      else
        curr << part
      end
    end
  end
end

enums     = kinds['enum']
functions = kinds['function']

# ---------------------------------------------

print <<-EOF
/* lua wrapping for #{module_name} generated by swigl.
 */
EOF

print("\n")

if true
  print("/* inputs...\n")
  kinds.keys.sort.each do |k|
    print("  #{k}:\n")
    kind = kinds[k]
    kind.keys.sort.each do |n|
      print("    #{n}:\n")
      print("      #{kind[n].join('><')}\n")
    end
  end
  print("\n")
  print("*/\n")
  print("\n")
end

# ---------------------------------------------

print <<-EOF
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#{'#include "' + include_files.join("\n#include \"") + '"'}
EOF

print("\n")

# ---------------------------------------------

wrap_template = ERB.new <<-EOF
static int wrap_<%= name %>(lua_State *L) {
  return 0;
}
EOF

# ---------------------------------------------

functions.keys.sort.each do |k|
  name, kind, extra = name_kind(functions[k])
  print(wrap_template.result(binding))
end

# ---------------------------------------------

entry_template = ERB.new <<-EOF
LUA_API int luaopen_<%= module_name %>(lua_State *L) {
    luaL_reg reg[] = {
        <% functions.keys.sort.each do |k| %>
        {"<%= k %>", wrap_<%= k %>},
        <% end %>
        {NULL, NULL}
    };
    luaL_register(L, "<%= module_name %>", reg);

    <% enums.keys.sort.each do |k| %>
      <% enum_values(enums[k]).each do |v| %>
        lua_pushinteger(L, (lua_Integer) <%= v %>);
        lua_setfield(L, -2, "<%= v %>");
      <% end %>
    <% end %>

    return 1;
}
EOF

print(entry_template.result(binding))
