#!/usr/bin/env ruby

# Poor man's SWIG just for lua, which uses STDIN and STDOUT.
#
#   ./swigl <module_name> [opt.h opt2.h ...]
#   cat some.h | ./swigl some_wrap some.h > some_wrap.c
#
require 'rubygems'
require 'erb'

$skip = {}

module_name   = $module_name   = ARGV[0]
include_files = $include_files = ARGV[1..-1]

load($module_name + ".swigl") if File.exists?($module_name + ".swigl")

src = STDIN.read
src = src.gsub(/^\s*#.+$/, '')

MAP_C2LUA = {
  # [ luaL_check$VAL, lua_push$VAL ]
  'int'    => ['int', 'integer'],
  'long'   => ['long', 'integer'],
  'double' => ['number', 'number'],
  'char *' => ['string', 'string']
}

# ---------------------------------------------

def name_kind(curr)
  first_parts = curr[0].split(' ').
                        select {|x| x != "extern" and x != "__const" }

  case first_parts[0]
    when 'typedef'
      if curr[-1] == ')' and
         curr.count {|x| x == '(' } > 1
        # Example: typedef void (*uv_close_cb)(uv_handle_t* handle);
        return curr[curr.index('(') + 1], first_parts[0], 'function'
      end

      # Example: typedef enum { ...} name_of_enum;
      return curr[-1].split(' ')[-1], 'enum' if first_parts[1] == 'enum'

      # Example: typedef struct uv_req_s uv_req_t;
      return curr[-1].split(' ')[-1], first_parts[0]

    when 'struct', 'union', 'enum'
      # Example: struct cmsghdr
      # Example: struct cmsghdr{int foo; int bar}
      return first_parts[-1], first_parts[0]

    else
      if curr.include?('(')
        # Example: void uv_init();
        return first_parts[-1], 'function',
               first_parts[0..-2]
      end

      print "ERROR: unknown name/type for #{curr.join("><")}\n"
      exit(-1)
  end
end

def enum_values(curr)
  res = []
  lhs = curr.index('{') + 1
  rhs = curr.index('}') - 1
  vals = curr[lhs..rhs]
  vals.each do |e|
    e.split(',').each do |v|
      v = v.split('=')[0].strip
      res << v
    end
  end
  res
end

# ---------------------------------------------

kinds = {}
curr = []

parts = src.split(/([\;\{\}\(\)])/) # Main parser loop.
parts.each do |part|
  if part
    part = part.strip.gsub("\n", " ").squeeze(" \n\t")
    if part != ""
      if part == ";" and
         curr.count {|x| x == "{" } == curr.count {|x| x == "}" }
        n, k = name_kind(curr)
        if n.nil? or k.nil?
          print "\n\nERROR: missing name in #{curr.join("><")}\n"
          exit(-1)
        end

        n = n.gsub('*', '')

        kinds[k] ||= {}
        if kinds[k][n]
          print("ERROR: duplicate name: #{n}, for kind: #{k}," \
                " in: #{curr.join('><')}," \
                " previously: #{kinds[k][n].join('><')}\n")
        end

        kinds[k][n] = curr

        curr = []
      else
        curr << part
      end
    end
  end
end

enums     = kinds['enum']
functions = kinds['function']

# ---------------------------------------------

print <<-EOF
// lua wrapping for #{module_name} generated by swigl.

EOF

if true
  print("/* inputs...\n")
  kinds.keys.sort.each do |k|
    print("  #{k}:\n")
    kind = kinds[k]
    kind.keys.sort.each do |n|
      print("    #{n}:\n")
      print("      #{kind[n].join('><')}\n")
    end
  end
  print("\n*/\n\n")
end

# ---------------------------------------------

print <<-EOF
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#{include_files.map {|x| "#include \"#{x}\"" }.join("\n")}

EOF

# ---------------------------------------------

def arg_parts(arg, arg_i)
  p = arg.gsub('*', ' * ').squeeze(' ').strip.split(' ')
  q = p.select {|x| x != 'struct' and
                    x != 'const' and
                    x != '*' }
  p << "arg_#{arg_i}" if q.length < 2
  arg_type = p[0..-2].select {|x| x != 'const' }
  arg_name = p[-1]
  return arg_type, arg_name
end

def arg_lua2c(arg_type, arg_name, arg_i)
  t = arg_type.select {|x| x != 'signed' and
                           x != 'unsigned' }.join(' ')
  check_val, push_val = MAP_C2LUA[t]
  if check_val
    <<-EOF
#{arg_name} =
        (#{arg_type.join(' ')}) luaL_check#{check_val}(L, #{arg_i + 1});
EOF
  else
    short_t = t.gsub('*', 'ptr').
                gsub('struct ', '').
                gsub('const ', '').
                squeeze(' ').strip.gsub(' ', '_')
    <<-EOF
#{arg_type.join(' ')} *#{arg_name}_p =
        luaL_checkudata(L, #{arg_i + 1}, "#{$module_name}.#{short_t}");
    #{arg_name} = *#{arg_name}_p;
EOF
  end
end

def args_names(args)
  arg_i = 0
  args.map do |arg|
    arg_type, arg_name = arg_parts(arg, arg_i)
    arg_i = arg_i + 1
    arg_name
  end
end

wrap_function = ERB.new(<<-'EOF', 0, "%<>")
static int wrap_<%= name %>(lua_State *L) {
% args.each_index do |arg_i|
%   arg_type, arg_name = arg_parts(args[arg_i], arg_i)
    <%= arg_type.join(' ') %> <%= arg_name %>;
    <%= arg_lua2c(arg_type, arg_name, arg_i) %>
% end
% if return_type.include?('void')
    <%= name %>(<%= args_names(args).join(', ') %>);
    return 0;
% else
%   return_s = return_type.join(' ').
%                          gsub('*', ' * ').squeeze(' ').strip
    <%= return_s %> res =
        <%= name %>(<%= args_names(args).join(', ') %>);
    return 0;
% end
}
EOF

functions.keys.sort.each do |k|
  curr = functions[k]

  name, kind, return_type = name_kind(curr)

  args_s = curr[(curr.rindex("(") + 1)..-2].join('').strip
  args_s = "" if args_s == "void"
  args   = args_s.split(',')

  print(wrap_function.result(binding)) unless $skip[name]
end

# ---------------------------------------------

entry_template = ERB.new(<<-'EOF', 0, "%<>")
LUA_API int luaopen_<%= module_name %>(lua_State *L) {
    luaL_reg reg[] = {
% functions.keys.sort.each do |k|
%   unless $skip[k]
        {"<%= k %>", wrap_<%= k %>},
%   end
% end
        {NULL, NULL}
    };
    luaL_register(L, "<%= module_name %>", reg);

% enums.keys.sort.each do |k|
%   enum_values(enums[k]).each do |v|
    lua_pushinteger(L, (lua_Integer) <%= v %>);
    lua_setfield(L, -2, "<%= v %>");

%   end
% end

    return 1;
}
EOF

print(entry_template.result(binding))
